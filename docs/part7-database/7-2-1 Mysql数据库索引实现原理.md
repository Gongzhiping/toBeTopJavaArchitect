## Mysql数据库索引实现原理

- [一、树的介绍](#树的介绍)
- [二、索引的实现](#索引的实现)
    - [2.1 MyISAM 索引实现](#MyISAM索引实现)
    - [2.2 InnoDB 索引实现](#InnoDB索引实现)
    - [2.3 聚簇索引与非聚簇索引](#聚簇索引与非聚簇索引)
    - [2.4 联合索引及最左原则](#联合索引及最左原则)
- [三、InnoDB和MyISAM区别](#InnoDB和MyISAM区别)
- [四、为什么Mysql不选择Hash索引](#为什么Mysql不选择Hash索引)
- [五、导致索引失效的可能情况](#导致索引失效的可能情况)

### 树的介绍

#### 1. 二叉搜索树
在介绍索引实现之前，我们先来了解下几种树的数据结构。

**二叉搜索树**

二叉搜索树有以下性质

1. 每个节点有一个关键字
2. 左右孩子至多有一个。
3. 关键字大于左孩子，小于右孩子。

正因为二叉搜索树的特性，所以这种数据结构很适合用来做搜索，效率等同于二分查找，时间复杂度为log2(n),

![二叉搜索树](https://img-blog.csdnimg.cn/20190601200731263.png)

但是这种最原始的二叉树有一个弊端，在极端的情况下会退化成链表

![链表](https://img-blog.csdnimg.cn/20190601201237453.png)

所以基础二叉搜索树有很多变种，例如红黑树和AVL树，基于特定的策略避免了树退化成链表，红黑树做数据量不大的搜索还是应用很广泛的，
但是要基于**文件索引系统却不合适**，因为**红黑树虽然搜索效率高，但是树的高度比B-树和B+树要高，需要进行的磁盘IO就多**，
相比之下后者优势就比较明显了。

#### 2.B-树
一种多路搜索树，不是二叉树

我们来看一个m阶B树

它有如下几个性质
1. 根节点至少有2个孩子，根节点孩子数为[2,m]。
2. 除根节点外每个非叶子节点的孩子数为[m/2,m]（向上取整）。
3. 非叶子节点的关键字个数=指向孩子的指针树-1。
4. 所有叶子节点在同一层且关键字个数为k-1, 其中 m/2 <= k <= m
5. 节点之间关键字的大小，类比二叉搜索树，即关键字的值按大小排列，pi的关键字的值属于（k[i],k[i+1]）开区间，例如 p2的关键字要大于17，小于35。

![一种多路搜索树](https://img-blog.csdnimg.cn/20190601202211447.png)

B-树相对与二叉搜索树来说，变得矮胖，这样能减少io读取的次数，其搜索效率也是log2(n)但这还不足以用来做文件索引。
因为B树有可能在非叶子节点命中数据，耗费存贮。所以文件索引一般用B+树。

#### 3. B+树
B+树建立在B-树的基础之上，更改了几条性质

1. 非叶子节点的关键字和孩子指针数相同
2. pi的关键字的值属于[k[i],k[i+1]]闭区间。
3. 为叶子节点添加一个指针

![B+树](https://img-blog.csdnimg.cn/20190601205310593.png)

B+树在B-树的基础上添加了叶子链表指针，方便查找相邻的数据。
所有数据只有在叶子节点才会被命中，非叶子节点只提供索引，这样非叶子节点可以存贮更多的数据，所以B+树很适合做文件索引，

### 索引的实现

目前大部分数据库系统及文件系统都采用B-Tree(B树)或其变种B+Tree(B+树)作为索引结构。
B+Tree是数据库系统实现索引的首选数据结构。在MySQL中,索引属于存储引擎级别的概念,不同存储引擎对索引的实现方式是不同的,
本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。

#### MyISAM索引实现

MyISAM [mi:sem]引擎使用 B+Tree 作为索引结构,叶节点的 data 域存放的是数据记录的地址。下图是 MyISAM 索引的原理图:

![MyISAM索引实现](http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/jpg/4ab4988a2c158a128c8ec2406d71402a.jpg)

这里设表一共有三列,假设我们以 Col1 为主键,则上图是一个 MyISAM 表的主索引(Primary key)示意。
可以看出 MyISAM 的索引文件仅仅保存数据记录的地址

**辅助索引**
在 MyISAM 中,主索引和辅助索引(Secondary key)在结构上没有任何区别,只是主索引要求 key 是唯一的,而辅助索引的 key 可以重复。
如果我们在 Col2 上建立一个辅助索引,则此索引的结构如下图所示：

![辅助索引](http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/jpg/8a27a81cde5d0f565d336d8b2501811b.jpg)

同样也是一颗 B+Tree,data 域保存数据记录的地址。因此,MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引,
如果指定的 Key 存在,则取出其data 域的值,然后以 data 域的值为地址,读取相应数据记录。

**MyISAM 的索引方式也叫做“非聚集索引”**,之所以这么称呼是为了与 InnoDB的聚集索引区分。

#### InnoDB索引实现

虽然 InnoDB 也使用 B+Tree 作为索引结构,但具体实现方式却与 MyISAM 截然不同。

1. 第一个重大区别是 InnoDB 的数据文件本身就是索引文件。从上文知道,MyISAM 索引文件和数据文件是分离的,索引文件仅保存数据记录的地址。

   而在InnoDB 中,表数据文件本身就是按 B+Tree 组织的一个索引结构,这棵树的叶点data 域保存了完整的数据记录。这个索引的 key 是数据表的主键,
   因此 InnoDB 表数据文件本身就是主索引。
    
   ![InnoDB索引实现](http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/jpg/a1f0dd22be4459abf8b984c832ade3c0.jpg)
    
   上图是 InnoDB 主索引(同时也是数据文件)的示意图,可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为 InnoDB 的数据文件本身要按主键聚集,
    
   **InnoDB 要求表必须有主键(MyISAM 可以没有)**,如果没有显式指定,则 MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键,
   如果不存在这种列,则MySQL 自动为 InnoDB 表生成一个隐含字段作为主键,类型为长整形。
    
   同时,请尽量在 InnoDB 上采用自增字段做表的主键。因为 InnoDB 数据文件本身是一棵B+Tree,非单调的主键会造成在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的分裂调整,
   十分低效,而使用自增字段作为主键则是一个很好的选择。如果表使用自增主键,那么每次插入新的记录,记录就会顺序添加到当前索引节点的后续位置,当一页写满,就会自动开辟一个新的页。如下图所示:
    
   ![InnoDB索引实现](http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/jpg/eb34cbdbd601d2b3a6d658cafbe2a08b.jpg)
    
   这样就会形成一个紧凑的索引结构,近似顺序填满。由于每次插入时也不需要移动已有数据,因此效率很高,也不会增加很多开销在维护索引上。

2. 第二个与 MyISAM 索引的不同是 InnoDB 的辅助索引 data 域存储相应记录主键的值而不是地址。换句话说,InnoDB 的所有辅助索引都引用主键作为 data 域。
   例如,图 11 为定义在 Col3 上的一个辅助索引:

   ![InnoDB索引实现](http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/jpg/78d019a47b6498aa770934ec102521a1.jpg)
 
   聚集索引这种实现方式使得按主键的搜索十分高效,但是辅助索引搜索需要检索两遍索引:首先检索辅助索引获得主键,然后用主键到主索引中检索获得记录。

   引申:为什么不建议使用过长的字段作为主键?

   因为所有辅助索引都引用主索引,过长的主索引会令辅助索引变得过大。

#### 聚簇索引与非聚簇索引

**InnoDB 使用的是聚簇索引**, 将主键组织到一棵 B+树中, 而行数据就储存在叶子节点上, 若使用"where id = 14"这样的条件查找主键, 
则按照 B+树的检索算法即可查找到对应的叶节点, 之后获得行数据。 若对 Name 列进行条件搜索, 则需要两个步骤:
- 第一步在辅助索引 B+树中检索 Name, 到达其叶子节点获取对应的主键。
- 第二步使用主键在主索引 B+树种再执行一次 B+树检索操作, 最终到达叶子节点即可获取整行数据。

**MyISAM 使用的是非聚簇索引**, 非聚簇索引的两棵 B+树看上去没什么不同, 节点
的结构完全一致只是存储的内容不同而已, 主键索引 B+树的节点存储了主键, 辅助键索引B+树存储了辅助键。 
表数据存储在独立的地方, 这两颗 B+树的叶子节点都使用一个地址指向真正的表数据, 对于表数据来说, 这两个键没有任何差别。 
由于索引树是独立的, 通过辅助键检索无需访问主键的索引树。

为了更形象说明这两种索引的区别, 我们假想一个表如下图存储了 4 行数据。 其中Id 作为主索引, Name 作为辅助索引。 
图示清晰的显示了聚簇索引和非聚簇索引的差异

![聚簇索引与非聚簇索引](http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/jpg/345f9050358efa70033be95ed06e337b.jpg)



#### 联合索引及最左原则
联合索引存储数据结构图：

![联合索引及最左原则](https://img-blog.csdnimg.cn/20190109134515235.png)

最左原则：

例如联合索引有三个索引字段（A,B,C）

查询条件：

（A，，）  ---会使用索引

（A，B，） ---会使用索引

（A，B，C）---会使用索引

（，B，C） ---不会使用索引

（，，C）  ---不会使用索引



### InnoDB和MyISAM区别
1. MySQL默认存储引擎的变迁
    
    在MySQL 5.1之前的版本中，默认的搜索引擎是MyISAM，从MySQL 5.5之后的版本中，默认的搜索引擎变更为InnoDB。

2. MyISAM与InnoDB存储引擎的主要特点
    - MyISAM存储引擎的特点是：表级锁、不支持事务和全文索引，适合一些CMS内容管理系统作为后台数据库使用，
      但是使用大并发、重负荷生产系统上，表锁结构的特性就显得力不从心；
    - InnoDB存储引擎的特点是：行级锁、事务安全（ACID兼容）、支持外键、不支持FULLTEXT类型的索引(5.6.4以后版本开始支持FULLTEXT类型的索引)。
      InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全存储引擎。InnoDB是为处理巨大量时拥有最大性能而设计的。
      它的CPU效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的。

    注意：
    InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “a%”。

    两种类型最主要的差别就是InnoDB支持事务处理与外键和行级锁。而MyISAM不支持。所以MyISAM往往就容易被人认为只适合在小项目中使用。

3. MyISAM与InnoDB性能测试

    下边两张图是官方提供的MyISAM与InnoDB的压力测试结果

    ![MyISAM与InnoDB性能测试](https://img-blog.csdn.net/20170403200641192)
    ![MyISAM与InnoDB性能测试](https://img-blog.csdn.net/20170403200653614)
    
    可以看出，随着CPU核数的增加，InnoDB的吞吐量反而越好，而MyISAM，其吞吐量几乎没有什么变化，
    显然，MyISAM的表锁定机制降低了读和写的吞吐量。

4. 事务支持与否

    MyISAM是一种非事务性的引擎，使得MyISAM引擎的MySQL可以提供高速存储和检索，以及全文搜索能力，适合数据仓库等查询频繁的应用；

    InnoDB是事务安全的；

    事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。

5. MyISAM与InnoDB构成上的区别

   （1）每个MyISAM在磁盘上存储成三个文件：

        第一个文件的名字以表的名字开始，扩展名指出文件类型，.frm文件存储表定义。
        第二个文件是数据文件，其扩展名为.MYD (MYData)。
        第三个文件是索引文件，其扩展名是.MYI (MYIndex)。

   （2）基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的 大小只受限于操作系统文件的大小，一般为 2GB。

6. MyISAM与InnoDB表锁和行锁的解释

    MySQL表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。
    什么意思呢，就是说对MyISAM表进行读操作时，它不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写操作；
    而对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作。

    InnoDB行锁是通过给索引项加锁来实现的，即只有通过索引条件检索数据，InnoDB才使用行级锁，否则将使用表锁！
    行级锁在每次获取锁和释放锁的操作需要消耗比表锁更多的资源。在InnoDB两个事务发生死锁的时候，会计算出每个事务影响的行数，
    然后回滚行数少的那个事务。当锁定的场景中不涉及Innodb的时候，InnoDB是检测不到的。只能依靠锁定超时来解决。

7. 是否保存数据库表中表的具体行数

    InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table 时，InnoDB要扫描一遍整个表来计算有多少行，
    但是MyISAM只要简单的读出保存好的行数即可。

    注意的是，当count(*)语句包含where条件时，两种表的操作是一样的。也就是 上述“6”中介绍到的InnoDB使用表锁的一种情况。

8、如何选择

    MyISAM适合：
    （1）做很多count 的计算；
    （2）插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择；
    （3）没有事务。
    
    InnoDB适合：
    （1）可靠性要求比较高，或者要求事务；
    （2）表更新和查询都相当的频繁，并且表锁定的机会比较大的情况指定数据引擎的创建；
    （3）如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表；
    （4）DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的 删除；
    （5）LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用。

    要注意，创建每个表格的代码是相同的，除了最后的 TYPE参数，这一参数用来指定数据引擎。

9. 其他区别：

    1、对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。
    
    2、DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。
    
    3、LOAD TABLE FROMMASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。
    
    4、 InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。
    
    5、对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。
    
    6、清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表。


### 为什么Mysql不选择Hash索引

Hash索引的优势是精确查找的话，速度会更快，为什么不选择Hash索引

- Hash索引不适合范围查找，而B+树特别适合范围查找（特别是聚簇索引的时候）
- Hash索引每次查询要加载所有的索引数据到内存当中，而B+树只需要根据匹配规则选择对应的叶子数据加载即可
- 另外B+树引入了缓存机制 和 数据页技术来提升性能（不过理论上来说，这两个特性Hash索引也可以实现）

### 导致索引失效的可能情况
1. 隐式转换导致索引失效.这一点应当引起重视.也是开发中经常会犯的错误.
   
       由于表的字段tu_mdn定义为varchar2(20),但在查询时把该字段作为number类型以where条件传给Oracle,这样会导致索引失效.
       错误的例子：select * fromtest where tu_mdn=13333333333;
       正确的例子：select * fromtest where tu_mdn='13333333333';
       
2. 对索引列进行运算导致索引失效,我所指的对索引列进行运算包括(+，-，*，/，! 等)

         错误的例子：select* from test where id-1=9;
         正确的例子：select * fromtest where id=10;
         
3. 使用Oracle内部函数导致索引失效.对于这样情况应当创建基于函数的索引.

         错误的例子：select * from test where round(id)=10;说明，此时id的索引已经不起作用了
         正确的例子：首先建立函数索引，create index test_id_fbi_idx on test(round(id));然后select * from test where round(id)=10; 这时函数索引起作用了

4. 以下使用会使索引失效，应避免使用；

        a. 使用 <> 、not in、not exist、!=
        b. like "%_"百分号在前（可采用在建立索引时用reverse(columnName)这种方法处理）
        c. 单独引用复合索引里非第一位置的索引列.应总是使用索引的第一个列，如果索引是建立在多个列上,只有在它的第一个列被 where子句引用时，优化器才会选择使用该索引。
        d.字符型字段为数字时在where条件里不添加引号.
        e.当变量采用的是times变量，而表的字段采用的是date变量时.或相反情况。

5. 不要将空的变量值直接与比较运算符（符号）比较。
    
        如果变量可能为空，应使用 IS NULL 或 IS NOT NULL 进行比较，或者使用 ISNULL函数。

6. 不要在 SQL 代码中使用双引号。
    
        因为字符常量使用单引号。如果没有必要限定对象名称，可以使用（非 ANSI SQL标准）括号将名称括起来。