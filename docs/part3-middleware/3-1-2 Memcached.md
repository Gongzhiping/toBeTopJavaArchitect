## Memecached

**一、memcached工作原理**

	基本概念：slab，page，chunk。
	slab，是一个逻辑概念。它是在启动memcached实例的时候预处理好的，每个slab对应一个chunk size，也就是说不同slab有不同的chunk size。具体分配多少个slab由参数 -f （增长因子）和 -n （chunk最小尺寸）决定的。
	page，可以理解为内存页。大小固定为1m。slab会在存储请求时向系统申请page，并将page按chunk size进行切割。
	chunk，是保存用户数据的最小单位。用户数据item（包括key，value）最终会保存到chunk内。chunk规格是固定的，如果用户数据放进来后还有剩余, 则这剩余部分不能做其他用途。

**二、memcached工作流程**

    memcahed实例启动，根据 -f 和 -n 进行预分配slab。以 -n 为最小值开始，以 -f 为比值生成等比数列，直到1m为止（每个slab的chunk size都要按8的倍数进行补全，比如：如果按比值算是556的话，会再加4到560成为8的整倍数）。然后每个slab分配一个page。当用户发来存储请求时（key,value），memcached会计算key+value的大小，看看属于哪个slab。确定slab后看里面的是否有空闲chunk放key+value，如果不够就再向系统申请一个page（如果此时已经达到 -m 参数设置的内存使用上限，则看是否设置了 -M 。如果设置了 -M 则返回错误提示，否则按LRU算法删除数据）。申请后将该page按本slab的chunk size 进行切割，然后分配一个来存放用户数据。
    注意：
    1）chunk是在page里面划分的，而page固定为1m，所以chunk最大不能超过1m。
    2）chunk实际占用内存要加48B，因为chunk数据结构本身需要占用48B。
    3）如果用户数据大于1m，则memcached会将其切割，放到多个chunk内。
    4）已分配出去的page不能回收。

**三、优化建议**

    1）-n 参数的设置，注意将此参数设置为1024可以整除的数（还要考虑48B的差值），否则余下来的部分就浪费了。
    2）不要存储超过1m的数据。因为要拆成多个chunk，计算和时间成本都成倍增加。
    3）善用stats命令查看memcached状态。
    4）消灭eviction（被删除的数据）。
        造成eviction是因为内存不够，有三个思路：
        (a). 在CPU有余力的情况下开启压缩（PHP扩展）；
        (b). 增加内存；
        (c). 调整-f参数，减少内存浪费。
    5）调整业务代码，提高命中率。
    6）缓存小数据。省带宽，省网络I/O时间，省内存。
    7）根据业务特点，为数据尺寸区间小的业务分配专用的memcached实例。这样可以调小 -f 参数，使数据集中存在少数几个slab上，内存浪费较少。
    
    启动时最重要的参数：
    -m 		整个memcached最大内存
    -f 		chunk大小增长因子
    -n 		chunk最小分配空间
    -C 		禁用CAS
    -vvv 	打印详细信息
        我们通过计算可以看出，每个slab的chunk size大小都是上一个大小的1.25倍，1.25就是memcached启动时制定的-f的值，所以，要根据不同的业务场景调整，既要尽可能少的减少内存浪费，又要存得下我们业务中的数据，再举个例子，假如我们的业务很BT，大小都是200kb，我们该怎么做？那当然是要保证我们申请的chunk大小都是200kb了，虽然memcached并不支持这么做。假如创建了38个slabs，最后数据全都落到了第20-25个slab中，那0-19和26-38的内存就被浪费了，这只是能评估出来的，还有一种情况，加入我们的chunk大小是500kb，数据才200kb，因为每个chunk都只能存储一个，所以一个chunk就会有500kb-200kb的空间浪费，如果有一千万个chunk要存，那将会浪费多少空间？所以，在使用memcached之前，先要评估你的数据，根据它去调整-f因子。

**四、memcache经典的问题和现象**

6.1 缓存雪崩

缓存雪崩是指：因为某些节点挂掉，导致cache命中大大降低，然后短时间内大量的操作数据库，导致数据库也挂掉。
或者由于缓存失效时间比较集中，比如每6个小时失效一次，在失效时刻，会大量访问数据库，导致数据库挂掉。

解决方法： 
1. 将缓存时间放长，比如24小时、48小时。然后每天夜里，在访问量比较小，负载比较低的时候，做缓存和数据库同步。
2.  将缓存失效时间设置一个随机的值，如在3-9小时内随机，这样避免失效时间比较集中

6.2 缓存无底洞

当节点数越多的情况下，数据就越分散。这样在访问一个页面的时候，可能需要连很多个节点（这样大量的链接也耗费了很多资源），这样造成性能下降。
适当的选择key的映射方式，如user-111-age, user-111-name,user-111-address，这些key表示用户111的基本信息，如果完全将它们作为不同的key映射，很可能分散到不同的节点中。但是如取user-111作为key映射存储节点位置，则肯定在同一个节点中，这样只需要链接一次，就可以将该用户的所有信息都拿出来。

6.3 永远数据被踢

前面也提到过，并不是设置一个key没有过期时间，这个key就会永远存在于memcache中，因为还有LRU方式会踢掉。
如果防止永远数据被踢掉呢？就是 将永久数据很非永久数据分开存储。