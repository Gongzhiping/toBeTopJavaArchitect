## 垃圾收集的算法分析

- [一、常用的算法介绍](#常用的算法介绍)
- [二、System.gc()方法](#System.gc()方法)
- [三、finalize()方法](#finalize()方法 )
- [四、触发主GC的条件](#触发主GC的条件 )
- [五、减少GC开销的措施](#减少gc开销的措施)

### 常用的算法介绍
Java语言规范没有明确地说明JVM使用哪种垃圾回收（Garbage Collector）算法，但是任何一种垃圾回收算法一般要做2件基本的事情：
1. 发现无用信息对象；
2. 回收被无用对象占用的内存空间，使该空间可被程序再次使用.

下面介绍几个常用的算法。

**1. 引用计数法(Reference Counting Collector)**

    引用计数法是唯一没有使用根集的垃圾回收的法，该算法使用引用计数器来区分存活对象和不再使用的对象。
    一般来说，堆中的每个对象对应一个引用计数器。当每一次创建一个对象并赋给一个变量时，引用计数器置为1。
    当对象被赋给任意变量时，引用计数器每次加1当对象出了作用域后(该对象丢弃不再使用)，引用计数器减1，
    一旦引用计数器为0，对象就满足了垃圾收集的条件。

    基于引用计数器的垃圾收集器运行较快，不会长时间中断程序执行，适宜地必须实时运行的程序。
    但引用计数器增加了程序执行的开销，因为每次对象赋给新的变量，计数器加1，而每次现有对象出了作用域生，计数器减1。
 
**2. tracing算法(Tracing Collector)**

    tracing算法是为了解决引用计数法的问题而提出，它使用了根集的概念。基于tracing算法的垃圾收集器从根集开始扫描，
    识别出哪些对象可达，哪些对象不可达，并用某种方式标记可达对象，例如对每个可达对象设置一个或多个位。
    在扫描识别过程中，基于tracing算法的垃圾收集也称为标记和清除(mark-and-sweep)垃圾收集器.但此算法会导致内存碎片问题；

**3. compacting算法(Compacting Collector)**

    为了解决堆碎片问题，基于tracing的垃圾回收吸收了Compacting算法的思想，在清除的过程中，
    算法将所有的对象移到堆的一端，堆的另一端就变成了一个相邻的空闲内存区，收集器会对它移动的所有对象的所有引用进行更新，
    使得这些引用在新的位置能识别原来的对象。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。
    
**4. copying算法(Coping Collector)**

    该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成一个对象区和多个空闲区，
    程序从对象区为对象分配空间，当对象满了，基于coping算法的垃圾回收就从根集中扫描活动对象，
    并将每个活动对象复制到空闲区(使得活动对象所占的内存之间没有空闲间隔)，这样空闲区变成了对象区，
    原来的对象区变成了空闲区，程序会在新的对象区中分配内存。
    
    一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象区和空闲区域区，
    在对象区与空闲区域的切换过程中，程序暂停执行。
    
**5. generation算法(Generational Collector)**

    stop-and-copy垃圾收集器的一个缺陷是收集器必须复制所有的活动对象，这增加了程序等待时间，
    这是coping算法低效的原因。在程序设计中有这样的规律：多数对象存在的时间比较短，少数的存在时间比较长。
    因此，generation算法将堆分成两个或多个，每个子堆作为对象的一代 (generation)。由于多数对象存在的时间比较短，
    随着程序丢弃不使用的对象，垃圾收集器将从最年轻的子堆中收集这些对象。在分代式的垃圾收集器运行后，
    上次运行存活下来的对象移到下一最高代的子堆中，由于老一代的子堆不会经常被回收，因而节省了时间。
    
**6. adaptive算法(Adaptive Collector)**

    在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，
    并将选择适当算法的垃圾收集器。

### System.gc()方法                                                         
使用System.gc()可以不管JVM使用的是哪一种垃圾回收的算法，都可以请求Java的垃圾回收. 需要注意的是，
调用System.gc()也仅仅是一个请求(建议)。JVM接受这个消息后，并不是立即做垃圾回收，而只是对几个垃圾回收算法做了加权，
使垃圾回收操作容易发生，或提早发生，或回收较多而已。
   
### finalize()方法                                                            
Java提供了缺省机制来终止该对象心释放资源，这个方法就是finalize()。它的原型为：protected void finalize() throws Throwable

在finalize()方法返回之后，对象消失，垃圾收集开始执行。原型中的throws Throwable表示它可以抛出任何类型的异常。

之所以要使用finalize()，是存在着垃圾回收器不能处理的特殊情况。假定你的对象（并非使用new方法）获得了一块“特殊”的内存区域，
由于垃圾回收器只知道那些显示地经由new分配的内存空间，所以它不知道该如何释放这块“特殊”的内存区域，那么这个时候java允许在类中定义一个由finalize()方法。

### 触发主GC的条件                                  
总的来说,有两个条件会触发主GC（Garbage Collector）:
1. 当应用程序空闲时,即没有应用线程在运行时,GC会被调用。
2. Java堆内存不足时,GC会被调用。
 
### 减少GC开销的措施                                                      
以下几个方面可以减少GC开销:
1. **不要显式调用System.gc()**

   此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。
2. **尽量减少临时对象的使用**

   临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。
3. **对象不用时最好显式置为Null**

    一般而言,为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。
4. **尽量使用StringBuffer,而不用String来累加字符串**

    由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象。
5. **能用基本类型如Int,Long,就不用Integer,Long对象**
    
    基本类型变量占用内存资源比相应对象占用的少得多,如果非必要,最好使用基本变量。
6. **尽量少用静态对象变量**

    静态变量属于全局变量,不会被GC回收,它们会一直占用内存。
7. **分散对象创建或删除的时间**

    集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC的机会。