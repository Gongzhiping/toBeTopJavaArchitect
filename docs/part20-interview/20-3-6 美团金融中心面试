## 美团金融中心面试


### 0、ThreadLocal怎么用？

[参考文档：ThreadLocal原理](https://www.cnblogs.com/fsmly/p/11020641.html)

### 1、countdownlantch闭锁、cyclicbarrirer栅栏、semaphore信号量
**1、CountdownLatch又叫闭锁**

首先CountdownLatch 是一次性的锁。使用后锁状态就消失。

允许一个或多个线程阻塞，等待前置线程执行完后后，即计数器减为零时，阻塞的线程才继续执行。调用await()方法的线程进行阻塞，前置线程调用countDown()计数器减一。

**2、CyclicBarrier 栅栏锁**

CyclicBarrier是可以重复使用的，基于可重入锁ReentrantLock和Condition状态实现。当一组线程中的某一线程执行到达栅栏时调用 barrier.await() 先把自己阻塞起来，等待这一组中的所有线程都执行到达后才继续往下执行

当有线程到达屏障调用await() 使用ReetrantLock的ConditionObject的等待队列，通过向Condition中等待队列添加元素实现阻塞，当条件满足唤醒等待队列中的线程，依次序执行。

**3. Semaphore [ˈseməfɔːr]基于AQS实现的用来限制访问特定资源的线程数**

**前两者的区别：闭锁是要等待前置线程执行完成。栅栏锁是这一组本身全部执行到达条件时才能继续**



### 2、CMS 和 G1 区别？

    CMS 并发标记清除。。 主要步骤是  初始收集-并发标记-重新标记-并发清除-重置
    G1 主要步骤：  初始标记-并发标记-重新标记-复制清除

    CMS的缺点是对CPU的要求比较高。
    G1的缺点是将内存化成了多块，所以对内存段的大小有很大的要求。

    CMS是清除，所以会有很多的内存碎片。
    G1是整理，所以碎片空间较小

    G1和CMS都是响应优先，他们的目的都是尽量控制 stop the world 的时间。

    G1和CMS的Full GC都是单线程 mark sweep compact算法，直到JDK10才优化成并行的。
    
    
**CMS是一款优秀的收集器，主要优点：并发收集、低停顿。**

缺点：
1. CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。
2. CMS收集器无法处理浮动垃圾，可能会出现“Concurrent Mode Failure（并发模式故障）”失败而导致Full GC产生。
   浮动垃圾：由于CMS并发清理阶段用户线程还在运行着，伴随着程序运行自然就会有新的垃圾不断产生，这部分垃圾出现的标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC中再清理。这些垃圾就是“浮动垃圾”。
3. CMS是一款“标记--清除”算法实现的收集器，容易出现大量空间碎片。当空间碎片过多，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。

**2、G1收集器**

G1是一款面向服务端应用的垃圾收集器。G1具备如下特点：
1. 并行于并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。
   部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。
2. 分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。
   它能够采用不同的方式去处理新创建的对象和已经存活了一段时间，熬过多次GC的旧对象以获取更好的收集效果。
3. 空间整合：与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
4. 可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1和ＣＭＳ共同的关注点，但Ｇ１除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，
5. G1运作步骤：
    - 1、初始标记；
    - 2、并发标记；
    - 3、最终标记；
    - 4、筛选回收



### 3、ConcurrentHashMap加锁的过程？
JDK6,7中的ConcurrentHashmap主要使用Segment来实现减小锁粒度，把HashMap分割成若干个Segment，在put的时候需要锁住Segment，get时候不加锁，
使用volatile来保证可见性，当要统计全局时（比如size），首先会尝试多次计算modcount来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回size。
如果有，则需要依次锁住所有的Segment来计算。

jdk7中ConcurrentHashmap中，当长度过长碰撞会很频繁，链表的增改删查操作都会消耗很长的时间，影响性能,所以jdk8 中完全重写了concurrentHashmap,代码量从原来的1000多行变成了 6000多 行，
实现上也和原来的分段式存储有很大的区别。

主要设计上的变化有以下几点: 
1. 不采用segment而采用node，锁住node来实现减小锁粒度。
2. 设计了MOVED状态 当resize的中过程中 线程2还在put数据，线程2会帮助resize。
3. 使用3个CAS操作来确保node的一些操作的原子性，这种方式代替了锁。
4. sizeCtl的不同值来代表不同含义，起到了控制的作用。

至于为什么JDK8中使用synchronized而不是ReentrantLock，我猜是因为JDK8中对synchronized有了足够的优化吧。


