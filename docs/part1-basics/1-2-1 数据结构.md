## 文章目录

- [一、简介说明](#一、简介说明)
- [二、数组](#二、数组)
- [三、链表](#三、链表)
    - [3.1-链表介绍](#3.1-链表介绍)
    - [3.2-数组与链表对比](#3.2-数组与链表对比)
- [四、堆栈](#四、堆栈)
- [五、队列](#五、队列)
- [六、树](#六、树)
- [七、图](#七、图)

### 一、简介说明
**数据结构：**
是指相互之间存在一种或多种特定关系的数据元素的集合。听起来是不是很抽象，
简单理解：数据结构就是描述对象间逻辑关系的学科。
比如：队列就是一种先进先出的逻辑结构，栈是一种先进后出的逻辑结构，家谱是一种树形的逻辑结构！

**数据存储结构：**
它是计算机的一个概念，简单讲，就是描述数据在计算机中存储方式的学科；
常用的数据存储方式就两种：顺序存储，非顺序存储！
- 顺序存储就是把数据存储在一块连续的存储介质（比如硬盘或内存）
  上—-举个例子：从内存中拿出第100个字节到1000个字节间的连续位置，存储数据；
  数组就是典型的顺序存储！
- 非顺序存储就是各个数据不一定存在一个连续的位置上，只要每个数据知道它前面的数据和后面的数据，
  就能把所有数据连续起来啦；链表就是典型的非顺序存储啦！

数组、链表、堆栈和队列是最基本的数据结构，任何程序都会涉及到其中的一种或多种。

下面简单描述一下数组、链表、堆栈、队列和二叉树

### 二、数组
数组是最最基本的数据结构，很多语言都内置支持数组。

数组是使用一块连续的内存空间保存数据，保存的数据的个数在分配内存的时候就是确定的：
![数组1](https://img-blog.csdn.net/20180819151406242?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0MjkwMTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

上图为包含N个数据的数组

访问数组中第 n 个数据的时间花费是 O(1) ，但是要在数组中查找一个指定的数据则是 O(N)。
当向数组中插入或者删除数据的时候，最好的情况是在数组的末尾进行操作，时间复杂度是O(1) ，
但是最坏情况是插入或者删除第一个数据，时间复杂度是 O(N) 。
在数组的任意位置插入或者删除数据的时候，后面的数据全部需要移动，移动的数据还是和数据个数有关所以总体的时间复杂度仍然是 O(N) 。

![数组插入](https://img-blog.csdn.net/20180819151504469?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0MjkwMTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

上图为插入一个数据

**数组的局限性分析：**
1. 插入快，对于无序数组，上面我们实现的数组就是无序的，即元素没有按照从大到小或者某个特定的顺序排列，
   只是按照插入的顺序排列。无序数组增加一个元素很简单，只需要在数组末尾添加元素即可，但是有序数组却不一定了，
   它需要在指定的位置插入。
2. 对于无序数组来说，查找慢，当然如果根据下标来查找是很快的。但是通常我们都是根据元素值来查找，给定一个元素值，
   对于无序数组，我们需要从数组第一个元素开始遍历，直到找到那个元素。有序数组通过特定的算法查找的速度会比无需数组快，
   后面我们会讲各种排序算法。
3. 删除慢，根据元素值删除，我们要先找到该元素所处的位置，然后将元素后面的值整体向前面移动一个位置。也需要比较多的时间。
4. 数组一旦创建后，大小就固定了，不能动态扩展数组的元素个数。如果初始化你给一个很大的数组大小，那会白白浪费内存空间，
   如果给小了，后面数据个数增加了又添加不进去了。


### 三、链表
#### 3.1 链表介绍
链表是在非连续的内存单元中保存数据，并且通过指针将各个内存单元链接在一起，最有一个节点的指针指向 NULL 。
链表不需要提前分配固定大小存储空间，当需要存储数据的时候分配一块内存并将这块内存插入链表中。

在链表中查找第 n 个数据以及查找指定的数据的时间复杂度是 O(N) ，但是插入和删除数据的时间复杂度是 O(1) ，
因为只需要调整指针就可以：

下面是链表图：

![链表](https://img-blog.csdn.net/20180819152219244?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0MjkwMTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

下面是向链表中插入数据：

![链表插入数据](https://img-blog.csdn.net/20180819152229117?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0MjkwMTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

下面试从链表中删除数据：

![链表删除数据](https://img-blog.csdn.net/20180819152248670?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0MjkwMTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

向上面这样的链表结构在插入和删除的时候编程会比较困难，因为需要记住当前节点的前一个节点，这样才能完成插入和删除。

为了简便通常使用带有头节点的链表：

![带头结点链表](https://img-blog.csdn.net/20180819152330101?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0MjkwMTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

上面的链表是单链表，此外还有双链表，就是节点中包含指向下一个节点的指针和指向上一个节点的指针,如下图：

![双向链表](https://img-blog.csdn.net/20180819152512257?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0MjkwMTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

不带有头节点的双向链表在插入和删除数据的时候也不会出现单链表那样的问题。

此外还有一种链表是循环链表，它是将双向链表的头尾相接：

![循环链表](https://img-blog.csdn.net/20180819152519111?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0MjkwMTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

向循环双向链表和循环链表中插入或者从中删除数据只是多移动几个指针。

#### 3.2 数组与链表对比
| 维度       | 数组   |  链表  |
| --------   | -----:  | :----:  |
| 空间性能   | 顺序表的存储空间是静态分布的，需要一个固定的数组，总有部分数组元素要浪费  |   链表的存储空间是动态分布，因此不会有空间被浪费。但由于链表需要额外的空间来为每个节点保存指针，因此也要牺牲一部分空间    |
| 时间性能        |   顺序表中的元素的逻辑顺序和物理存储顺序保持一致，而且支持随机存取。因此顺序表在查找，读取时候效率很快  |   链表采用链式结构来保存表内的元素，因此在插入、删除的时候效率比较高   |
### 四、堆栈
堆栈实现了一种后进先出的语义 (LIFO) 。可以使用数组或者是链表来实现它：

![堆栈](https://img-blog.csdn.net/20180819152718113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0MjkwMTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

对于堆栈中的数据的所有操作都是在栈的顶部完成的，只可以查看栈顶部的数据，只能够向栈的顶部压入数据，也只能从栈的顶部弹出数据

通过数组实现堆栈代码：
```java
public class MyStack {
	//底层实现是一个数组
	private long[] arr;
	private int top;
	/**
	 * 默认的构造方法
	 */
	public MyStack() {
		arr = new long[10];
		top = -1;
	}
	/**
	 * 带参数构造方法，参数为数组初始化大小
	 */
	public MyStack(int maxsize) {
		arr = new long[maxsize];
		top = -1;
	}
	/**
	 * 添加数据
	 */
	public void push(int value) {
		arr[++top] = value;
	}
	/**
	 * 移除数据
	 */
	public long pop() {
		return arr[top--];
	}
	/**
	 * 查看数据
	 */
	public long peek() {
		return arr[top];
	}
	/**
	 * 判断是否为空
	 */
	public boolean isEmpty() {
		return top == -1;
	}
	/**
	 * 判断是否满了
	 */
	public boolean isFull() {
		return top == arr.length - 1;
	}
}

/**测试类*/
public class TestMyStack {
	public static void main(String[] args) {
		MyStack ms = new MyStack(4);
		ms.push(23);
		ms.push(12);
		ms.push(1);
		ms.push(90);
		System.out.println(ms.isEmpty());
		System.out.println(ms.isFull());
		System.out.println(ms.peek());
		System.out.println(ms.peek());
		while(!ms.isEmpty()) {
			System.out.print(ms.pop() + ",");
		}
	}
}
```

### 五、队列
队列实现了先入先出的语义 (FIFO) 。队列也可以使用数组和链表来实现：

![队列](https://img-blog.csdn.net/20180819152925294?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0MjkwMTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

队列只允许在队尾添加数据，在队头删除数据。但是可以查看队头和队尾的数据。

还有一种是双端队列，在两端都可以插入和删除：

![双端队列](https://img-blog.csdn.net/2018081915293364?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0MjkwMTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

数组实现队列：
```java
/**
 * 列队类
 */
public class MyQueue {
	//底层使用数组
	private long[] arr;
	//有效数据的大小
	private int elements;
	//队头
	private int front;
	//队尾
	private int end;
	
	/**
	 * 默认构造方法
	 */
	public MyQueue() {
		arr = new long[10];
		elements = 0;
		front = 0;
		end = -1;
	}
	
	/**
	 * 带参数的构造方法，参数为数组的大小
	 */
	public MyQueue(int maxsize) {
		arr = new long[maxsize];
		elements = 0;
		front = 0;
		end = -1;
	}
	
	/**
	 * 添加数据,从队尾插入
	 */
	public void insert(long value) {
		arr[++end] = value;
		elements++;
	}
	
	/**
	 * 删除数据，从队头删除
	 */
	public long remove() {
		elements--;
		return arr[front++];
	}
	
	/**
	 * 查看数据，从队头查看
	 */
	public long peek() {
		return arr[front];
	}
	
	/**
	 * 判断是否为空
	 */
	public boolean isEmpty() {
		return elements == 0;
	}
	
	/**
	 * 判断是否满了
	 */
	public boolean isFull() {
		return elements == arr.length;
	}
}
/**测试类*/
public class TestMyQueue {
	public static void main(String[] args) {
		MyCycleQueue mq = new MyCycleQueue(4);
		mq.insert(23);
		mq.insert(45);
		mq.insert(13);
		mq.insert(1);
		System.out.println(mq.isFull());
		System.out.println(mq.isEmpty());
		System.out.println(mq.peek());
		while (!mq.isEmpty()) {
			System.out.print(mq.remove() + " ");
		}
	}
}
```

### 六、树

#### 6.1 基础概念
首先先看下下面这张图，我们理一下基本概念：

![树](../../sources/part1/树1.png)

我们先来认识一下树的一些常用术语，以上图为例介绍以下的术语： 
- **根结点：** 根结点是没有双亲的结点，一棵树中最多有一个根结点（如上图的A结点）。 
- **孩子结点：** 一棵树中，一个结点的子树的根结点称为其孩子结点，如上图的A的孩子结点右B、C、D。 
- **父母结点：** 相对于孩子结点而已其前驱结点即为父母结点，如上图的B、C、D 三个结点的父母结点都为A，当然E、F结点的父母结点则是B。 
- **兄弟结点：** 拥有相同的父母结点的所有孩子结点叫作兄弟结点，如上图B、C、D 三个结点共同父结点为A，因此它们是兄弟结点，E、F也是兄弟结点，但是F、G就肯定不是兄弟结点了。 
- **祖先结点：** 如果存在一条从根结点到结点Q的路径，而且结点P出现在这条路径上，那么P就是Q的祖先结点，而结点Q也称为P的子孙结点或者后代。如上图的E的祖先结点有A和B，而E则是A和B的子孙结点。 
- **叶子结点：** 没有孩子结点的结点叫作叶子结点，如E、F、G、H等。 
- **结点的度：** 指的是结点所拥有子树的棵数。如A的度为3，F的度为0，即叶子结点的度为0，而树的度则是树中各个结点度的最大值，如图（d）树的度为3（A结点） 
- **树的层：** 又称结点的层，该属性反映结点处于树中的层次位置，我们约定根结点的层为1，如上图所示，A层为1，B层为2，E的层为3。 
- **树的高度(深度)：** 是指树中结点的最大层数，图（d）的高度为3。 
- **边：** 边表示从父母结点到孩子结点的链接线，如上图（d）中A到B间的连线则称为边。

#### 6.2 二叉树
二叉树是数据结构中一种重要的数据结构，也是树表家族最为基础的结构。 

二叉树的定义：二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。
二叉树的第i层最多有2^{i-1}个结点；深度为k的二叉树至多有2^k-1个结点；对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。

![普通二叉树](../../sources/part1/普通二叉树.png)       

#### 6.3 满二叉树
一棵深度为k且有2^k-1个结点的二叉树称为满二叉树。 

![满二叉树](../../sources/part1/满二叉树.png)  

#### 6.4 完全二叉树
深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为完全二叉树。 

![完全二叉树](../../sources/part1/完全二叉树.png)
                  
#### 6.5 二叉排序树
二叉查找树定义：又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树： 
1) 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 
2) 若它的右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值； 
3) 它的左、右子树也分别为二叉排序树。 

![二叉排序树](../../sources/part1/二叉排序树.png)
 
#### 6.6 平衡二叉树
平衡二叉树（Balanced Binary Tree）又被称为AVL树。它或者是一棵空树，或者是具有下列性质的二叉树：
1)它的左子树和右子树都是平衡二叉树
2)左子树和右子树的深度之差的绝对值不超过1。
（注：平衡二叉树应该是一棵二叉排序树, 但 一颗二叉排序树未必是平衡二叉树）

![平衡二叉树](../../sources/part1/平衡二叉树.png)
              
#### 6.7 红黑树
红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其他路径长出2倍，因而是近似于平衡的。树中每个结点包含5个属性：color、key、left、right和p。如果一个结点没有子节点或父节点，则该结点相应的指针属性值为NIL，我们可以把这些NIL视为指向二叉搜索树的叶节点（外部结点）的指针，而把带关键字的结点视为树的内部结点。 
一棵红黑树是满足下面性质的二叉搜索树： 
1）每个结点或是红色的，或是黑色的； 
2）根结点是黑色的； 
3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的； 
4）如果一个结点是红色的，则它的两个子结点都是黑色的； 
5）对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。 
红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。 

![红黑树](../../sources/part1/红黑树.png)         







### 七、图
